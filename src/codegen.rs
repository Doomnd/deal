use anyhow::{bail, Context, Result};
use crate::ast::*;

pub fn emit_rust(unit: &CompilationUnit) -> Result<String> {
    // Find Main.main entry
    let mut main_block: Option<&Block> = None;
    for d in &unit.decls {
        if let Decl::Dealer(dd) = d {
            if let Some(entry) = &dd.entry_fn {
                if dd.name.0 == "Main" && entry.sig.name.0 == "main" {
                    main_block = Some(&entry.body);
                }
            }
        }
    }
    let main_block = main_block.context("Main dealer with fn main not found")?;

    let mut out = String::new();
    out.push_str("// Auto-generated by deal codegen\n");
    out.push_str("#![allow(unused_variables)]\n#![allow(unused_mut)]\n\n");
    out.push_str("fn print<T: std::fmt::Display>(x: T) { println!(\"{}\", x); }\n\n");
    out.push_str("fn main() {\n");
    gen_block(&mut out, main_block, 1)?;
    out.push_str("}\n");
    Ok(out)
}

fn indent(out: &mut String, level: usize) {
    for _ in 0..level { out.push_str("    "); }
}

fn gen_block(out: &mut String, block: &Block, level: usize) -> Result<()> {
    for stmt in &block.stmts {
        match stmt {
            Stmt::Expr(e) => {
                indent(out, level);
                let es = gen_expr(e)?;
                out.push_str(&es);
                out.push_str(";\n");
            }
            Stmt::IndexAssign { target, index, value } => {
                indent(out, level);
                out.push_str(&sanitize_ident(&target.0));
                out.push('[');
                out.push_str(&gen_expr(index)?);
                out.push_str(" as usize] = ");
                out.push_str(&gen_expr(value)?);
                out.push_str(";\n");
            }
            Stmt::Let { name, is_mut, ty: _, init } => {
                indent(out, level);
                out.push_str("let ");
                if *is_mut { out.push_str("mut "); }
                out.push_str(&sanitize_ident(&name.0));
                // rely on Rust inference for now
                if let Some(e) = init {
                    out.push_str(" = ");
                    out.push_str(&gen_expr(e)?);
                }
                out.push_str(";\n");
            }
            Stmt::Assign { target, value } => {
                indent(out, level);
                out.push_str(&sanitize_ident(&target.0));
                out.push_str(" = ");
                out.push_str(&gen_expr(value)?);
                out.push_str(";\n");
            }
            Stmt::If { pre_binding, cond, then_block, elifs, else_block } => {
                if let Some(b) = pre_binding {
                    indent(out, level);
                    out.push_str("let ");
                    if b.is_mut { out.push_str("mut "); }
                    out.push_str(&sanitize_ident(&b.name.0));
                    if let Some(init) = &b.init {
                        out.push_str(" = "); out.push_str(&gen_expr(init)?);
                    }
                    out.push_str(";\n");
                }
                indent(out, level);
                out.push_str("if ");
                out.push_str(&gen_expr(cond)?);
                out.push_str(" {\n");
                gen_block(out, then_block, level + 1)?;
                indent(out, level);
                out.push_str("}");
                for (ec, eb) in elifs {
                    out.push_str(" else if ");
                    out.push_str(&gen_expr(ec)?);
                    out.push_str(" {\n");
                    gen_block(out, eb, level + 1)?;
                    indent(out, level);
                    out.push_str("}");
                }
                if let Some(eb) = else_block {
                    out.push_str(" else {\n");
                    gen_block(out, eb, level + 1)?;
                    indent(out, level); out.push_str("}");
                }
                out.push_str("\n");
            }
            Stmt::For(fd) => {
                gen_for(out, fd, level)?;
            }
            Stmt::StartDealer { .. } => {
                // not supported in codegen yet; ignore
            }
        }
    }
    Ok(())
}

fn gen_for(out: &mut String, fd: &ForDecl, level: usize) -> Result<()> {
    match &fd.iterable {
        Expr::Range { start, end, inclusive } => {
            // numeric loops â€” use i64 in generated code
            let lhs = fd.var.get(0).map(|i| sanitize_ident(&i.0)).unwrap_or_else(|| "_i".into());
            indent(out, level);
            out.push_str("for ");
            out.push_str(&lhs);
            out.push_str(" in (");
            out.push_str(&gen_expr(start)?);
            out.push_str(" as i64)..");
            if *inclusive { out.push('='); }
            out.push('(');
            out.push_str(&gen_expr(end)?);
            out.push_str(") as i64 {\n");
            gen_block(out, &fd.body, level + 1)?;
            indent(out, level);
            out.push_str("}\n");
        }
        Expr::List(_) | Expr::Ident(_) => {
            // list iterations; support `for v in xs` and `for i, v in xs`
            let (lhs, rhs) = match (fd.var.get(0), fd.var.get(1)) {
                (Some(i), Some(v)) => (sanitize_ident(&i.0), Some(sanitize_ident(&v.0))),
                (Some(v), None) => (sanitize_ident(&v.0), None),
                _ => ("_v".into(), None),
            };
            match rhs {
                Some(v) => {
                    indent(out, level);
                    out.push_str("for ("); out.push_str(&lhs); out.push_str(", "); out.push_str(&v); out.push_str(") in ");
                    out.push_str(&gen_expr(&fd.iterable)?);
                    out.push_str(".iter().enumerate() {\n");
                }
                None => {
                    indent(out, level);
                    out.push_str("for "); out.push_str(&lhs); out.push_str(" in ");
                    out.push_str(&gen_expr(&fd.iterable)?);
                    out.push_str(".iter() {\n");
                }
            }
            gen_block(out, &fd.body, level + 1)?;
            indent(out, level); out.push_str("}\n");
        }
        other => bail!("unsupported for-iterable in codegen: {:?}", other),
    }
    Ok(())
}

fn gen_expr(e: &Expr) -> Result<String> {
    Ok(match e {
        Expr::Ref(inner) => gen_expr(inner)?,
        Expr::PipeArrow(lhs, rhs, _pattern) => {
            // Lower pipe to call: rhs(lhs). Pattern is ignored in codegen for now.
            match &**rhs {
                Expr::Call { callee, args } => {
                    let mut a = Vec::with_capacity(args.len() + 1);
                    a.push(gen_expr(lhs)?);
                    for ar in args { a.push(gen_expr(ar)?); }
                    format!("{}({})", gen_expr(callee)?, a.join(", "))
                }
                _ => format!("{}({})", gen_expr(rhs)?, gen_expr(lhs)?),
            }
        }
        Expr::String(s) => format!("\"{}\".to_string()", s.replace('"', "\\\"")),
        Expr::Number(n) => {
            if n.fract() == 0.0 { format!("{}", *n as i64) } else { format!("{}f64", n) }
        }
        Expr::Bool(b) => format!("{}", b),
        Expr::Ident(id) => sanitize_ident(&id.0),
        Expr::List(items) => {
            let inner: Result<Vec<String>> = items.iter().map(gen_expr).collect();
            format!("vec![{}]", inner?.join(", "))
        }
        Expr::Tuple(items) => {
            let inner: Result<Vec<String>> = items.iter().map(gen_expr).collect();
            format!("({})", inner?.join(", "))
        }
        Expr::EmptyListOf(ty) => format!("Vec::<{}>::new()", map_type(ty)),
        Expr::Unary { op, expr } => match op {
            UnOp::Not => format!("!({})", gen_expr(expr)?),
            UnOp::Neg => format!("-({})", gen_expr(expr)?),
        },
        Expr::Binary { op, left, right } => {
            let l = gen_expr(left)?; let r = gen_expr(right)?;
            let op_str = match op {
                BinOp::Add => "+", BinOp::Sub => "-", BinOp::Mul => "*", BinOp::Div => "/", BinOp::Mod => "%",
                BinOp::Pow => return Ok(format!("({}).powf({})", l, r)),
                BinOp::Lt => "<", BinOp::Le => "<=", BinOp::Gt => ">", BinOp::Ge => ">=",
                BinOp::Eq => "==", BinOp::Ne => "!=",
            };
            format!("(({}) {} ({}))", l, op_str, r)
        }
        Expr::Call { callee, args } => {
            if let Expr::Ident(Ident(name)) = &**callee { if name == "print" {
                let a = gen_expr(&args[0])?; return Ok(format!("print({})", a)); } }
            bail!("unsupported call in codegen")
        }
        Expr::Range { start, end, inclusive } => {
            let l = gen_expr(start)?; let r = gen_expr(end)?;
            if *inclusive { format!("(({}) as i64)..=(({}) as i64)", l, r) } else { format!("(({}) as i64)..(({}) as i64)", l, r) }
        }
        Expr::Index { target, index } => format!("({})[({}) as usize]", gen_expr(target)?, gen_expr(index)?),
        Expr::Slice { .. } => bail!("slice not supported in codegen yet"),
        Expr::StructLit { .. } => bail!("struct literal not supported in codegen yet"),
        Expr::Member { .. } => bail!("member not supported in codegen yet"),
        Expr::Await(_) | Expr::Recv | Expr::Send { .. } | Expr::Unit => "()".to_string(),
    })
}

fn map_type(t: &TypeName) -> String {
    match t {
        TypeName::Int | TypeName::I64 => "i64".into(),
        TypeName::I8 => "i8".into(),
        TypeName::I16 => "i16".into(),
        TypeName::I32 => "i32".into(),
        TypeName::U8 => "u8".into(),
        TypeName::U16 => "u16".into(),
        TypeName::U32 => "u32".into(),
        TypeName::U64 => "u64".into(),
        TypeName::F32 => "f32".into(),
        TypeName::F64 => "f64".into(),
        TypeName::Char => "char".into(),
        TypeName::String => "String".into(),
        TypeName::Bool => "bool".into(),
        TypeName::Dealer => "()".into(),
        TypeName::Any => "()".into(),
        TypeName::Named(_) => "()".into(),
        TypeName::Generic { .. } => "()".into(),
        TypeName::List(inner) => format!("Vec<{}>", map_type(inner)),
        TypeName::Unit => "()".into(),
    }
}

fn sanitize_ident(name: &str) -> String {
    // Very basic: avoid Rust keywords minimal set; prefix with r# to use raw identifiers
    match name {
        "self" | "super" | "crate" | "mod" | "fn" | "let" | "for" | "if" | "else" | "loop" | "match" => format!("r#{}", name),
        _ => name.to_string(),
    }
}


